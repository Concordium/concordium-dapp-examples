{
  "version": 3,
  "sources": ["../../node_modules/@concordium/react-components/src/useConnect.ts", "../../node_modules/@concordium/react-components/src/error.ts", "../../node_modules/@concordium/react-components/src/useConnection.ts", "../../node_modules/@concordium/react-components/src/useContractSelector.ts", "../../node_modules/@concordium/react-components/src/useGrpcClient.ts", "../../node_modules/@concordium/react-components/src/useWalletConnectorSelector.ts", "../../node_modules/@concordium/react-components/src/WithWalletConnector.ts"],
  "sourcesContent": ["import { useCallback, useState } from 'react';\nimport { WalletConnection, WalletConnector } from '@concordium/wallet-connectors';\nimport { errorString } from './error';\n\n/**\n * The state of the a {@link useConnect} instance.\n */\nexport interface Connect {\n    /**\n     * Function for initiating a new connection. Any existing connection will not be automatically disconnected.\n     */\n    connect: () => void;\n\n    /**\n     * Indicator on whether we're waiting for a connection to be established and approved.\n     */\n    isConnecting: boolean;\n\n    /**\n     * Error establishing the connection.\n     */\n    connectError: string;\n}\n\n/**\n * Hook that exposes a function for initiating a connection on the provided {@link connector} and,\n * if successful, store the resulting connection in {@link setConnection}.\n * The hook also exposes the status of the connection progress and error if initiation failed.\n * @param connector The connector from which new connections are to be initiated.\n * @param setConnection The setter function to which new connections are passed.\n */\nexport function useConnect(\n    connector: WalletConnector | undefined,\n    setConnection: (c: WalletConnection) => void\n): Connect {\n    const [isConnecting, setIsConnecting] = useState(false);\n    const [connectError, setConnectError] = useState('');\n    const connect = useCallback(() => {\n        if (!connector) {\n            throw new Error('no connector to connect from');\n        }\n        setIsConnecting(true);\n        connector\n            .connect()\n            .then((c) => {\n                if (c) {\n                    setConnection(c);\n                    setConnectError('');\n                }\n            })\n            .catch((e) => setConnectError(errorString(e)))\n            .finally(() => setIsConnecting(false));\n    }, [connector, setConnection]);\n    return { connect, isConnecting, connectError };\n}\n", "export function errorString(err: any): string {\n    return (err as Error).message || (err as string);\n}\n", "import { useEffect, useState } from 'react';\nimport { WalletConnection } from '@concordium/wallet-connectors';\n\n/**\n * The state of the a {@link useConnection} instance.\n */\nexport interface Connection {\n    /**\n     * The current connection.\n     */\n    connection: WalletConnection | undefined;\n\n    /**\n     * Function for setting or resetting {@link connection}.\n     * @param connection The wallet connection.\n     */\n    setConnection: (connection: WalletConnection | undefined) => void;\n\n    /**\n     * The selected account of the connection.\n     */\n    account: string | undefined;\n\n    /**\n     * The hash of the genesis block for the chain that {@link account} lives on.\n     */\n    genesisHash: string | undefined;\n}\n\n/**\n * Hook for managing a connection and exposing its state.\n * The connection is automatically pruned from the state when it disconnects.\n * @param connectedAccounts Mapping from open connections to their selected accounts or the empty string if there isn't one.\n * @param genesisHashes Mapping from open connections to the hash of the genesis block for the chain that the selected accounts of the connections live on.\n */\nexport function useConnection(\n    connectedAccounts: Map<WalletConnection, string | undefined>,\n    genesisHashes: Map<WalletConnection, string | undefined>\n): Connection {\n    const [connection, setConnection] = useState<WalletConnection>();\n    useEffect(() => {\n        // Unset disconnected connection.\n        if (connection && !connectedAccounts.has(connection)) {\n            setConnection(undefined);\n        }\n    }, [connectedAccounts]);\n    return {\n        connection,\n        setConnection,\n        genesisHash: connection && genesisHashes.get(connection),\n        account: connection && connectedAccounts.get(connection),\n    };\n}\n", "import { useEffect, useState } from 'react';\nimport {\n    AccountAddress,\n    CcdAmount,\n    ConcordiumGRPCClient,\n    ContractAddress,\n    ContractName,\n    ReceiveName,\n} from '@concordium/web-sdk';\nimport { errorString } from './error';\n\n/**\n * Data and state of a smart contract.\n */\nexport interface Info {\n    /**\n     * Version of the contract's semantics.\n     */\n    version: number;\n\n    /**\n     * The contract's index on the chain.\n     */\n    index: bigint;\n\n    /**\n     * The contract's name without the \"init_\" prefix.\n     */\n    name: string;\n\n    /**\n     * The contract's balance.\n     */\n    amount: CcdAmount.Type;\n\n    /**\n     * The address of the account that owns the contract.\n     */\n    owner: AccountAddress.Type;\n\n    /**\n     * The contract's invokable methods.\n     */\n    methods: string[];\n\n    /**\n     * The reference identifier of the contract's module.\n     */\n    moduleRef: string;\n}\n\nasync function refresh(rpc: ConcordiumGRPCClient, index: bigint): Promise<Info> {\n    const info = await rpc.getInstanceInfo(ContractAddress.create(index, BigInt(0)));\n    if (!info) {\n        throw new Error(`contract ${index} not found`);\n    }\n\n    const { version, name, owner, amount, methods, sourceModule } = info;\n    return {\n        version,\n        index,\n        name: ContractName.fromInitName(name).value,\n        amount,\n        owner,\n        methods: methods.map(ReceiveName.toString),\n        moduleRef: sourceModule.moduleRef,\n    };\n}\n\nfunction parseContractIndex(input: string) {\n    try {\n        return BigInt(input);\n    } catch (e) {\n        throw new Error(`invalid contract index '${input}'`);\n    }\n}\n\nasync function loadContract(rpc: ConcordiumGRPCClient, input: string) {\n    const index = parseContractIndex(input);\n    return refresh(rpc, index);\n}\n\n/**\n * A {@link useContractSelector} instance.\n */\nexport interface ContractSelector {\n    /**\n     * The selected contract info, if available.\n     * Is undefined if there isn't any index to look up, during lookup, or the lookup failed.\n     * In the latter case {@link error} will be non-empty.\n     */\n    selected: Info | undefined;\n\n    /**\n     * Indicator of whether the lookup is in progress.\n     */\n    isLoading: boolean;\n\n    /**\n     * Error parsing the input string or RPC error looking up the contract.\n     */\n    error: string;\n}\n\n/**\n * React hook to look up a smart contract's data and state from its index.\n * @param rpc gRPC client through which to perform the lookup. The JSON-RPC client is supported for backwards compatibility only.\n * @param input The index of the contract to look up.\n * @return The resolved contract and related state.\n */\nexport function useContractSelector(rpc: ConcordiumGRPCClient | undefined, input: string): ContractSelector {\n    const [selected, setSelected] = useState<Info>();\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState('');\n    useEffect(() => {\n        setSelected(undefined);\n        setError('');\n        if (rpc && input) {\n            setIsLoading(true);\n            loadContract(rpc, input)\n                .then(setSelected)\n                .catch((err) => {\n                    setError(errorString(err));\n                    setSelected(undefined); // prevents race condition against an ongoing successful query\n                })\n                .finally(() => setIsLoading(false));\n        }\n    }, [rpc, input]);\n    return { selected, isLoading, error };\n}\n", "import { useEffect, useState } from 'react';\nimport { Network } from '@concordium/wallet-connectors';\nimport { ConcordiumGRPCClient } from '@concordium/web-sdk';\nimport { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport';\n\n/**\n * React hook that obtains a gRPC Web client for interacting with a node on the appropriate network.\n */\nexport function useGrpcClient({ grpcOpts }: Network): ConcordiumGRPCClient | undefined {\n    const [client, setClient] = useState<ConcordiumGRPCClient>();\n    useEffect(() => {\n        if (!grpcOpts) {\n            return setClient(undefined);\n        }\n        // No exceptions should ever be thrown from here.\n        setClient(new ConcordiumGRPCClient(new GrpcWebFetchTransport(grpcOpts)));\n    }, [grpcOpts]);\n    return client;\n}\n", "import { useCallback } from 'react';\nimport { WalletConnection } from '@concordium/wallet-connectors';\nimport { ConnectorType, WalletConnectionProps } from './WithWalletConnector';\n\n/**\n * The state of the a {@link useWalletConnectorSelector} instance.\n */\nexport interface WalletConnectorSelector {\n    /**\n     * Indicator of whether the selector is selected (i.e. it matches the active connector type).\n     */\n    isSelected: boolean;\n\n    /**\n     * Indicator of whether the selector is connected (i.e. it's selected and has an active connection).\n     */\n    isConnected: boolean;\n\n    /**\n     * Indicator of whether the selector is disabled (i.e. there is another connected selector).\n     */\n    isDisabled: boolean;\n\n    /**\n     * Handler function to be called when the selector is invoked.\n     * It will disconnect all existing connections and set the active connector type to the one of this selector.\n     * If the selector is already selected, it will reset the connector type to allow other connector types to be activated.\n     * The function should not be called if the selector is disabled.\n     */\n    select: () => void;\n}\n\n/**\n * Hook for managing a connector selector (usually a button in the UI).\n *\n * More precisely, the hook computes the derived state {@link WalletConnectorSelector} from {@link props} as follows:\n * - The selector is {@link WalletConnectorSelector.isSelected selected} if the active connector's type is {@link connectorType}.\n * - The selector is {@link WalletConnectorSelector.isConnected connected} if it is selected and the active connection was created by the active connector.\n * - The selector is {@link WalletConnectorSelector.isDisabled disabled} if it there is another connected selector.\n *\n * It also exposes a {@link WalletConnectorSelector.select handler function} for connecting/disconnecting appropriately\n * when the selector is invoked.\n *\n * @param connectorType The connector type controlled by this selector.\n * @param connection The connection that, if present and originating from the selected connector, causes that connector to be considered \"connected\".\n * @param props The props exposed by {@link WithWalletConnector} to its child component.\n * @return The resolved state.\n */\nexport function useWalletConnectorSelector(\n    connectorType: ConnectorType,\n    connection: WalletConnection | undefined,\n    props: WalletConnectionProps\n): WalletConnectorSelector {\n    const { activeConnectorType, activeConnector, setActiveConnectorType } = props;\n    const isSelected = activeConnectorType === connectorType;\n    const select = useCallback(\n        () => setActiveConnectorType(isSelected ? undefined : connectorType),\n        [isSelected, connectorType]\n    );\n    const isConnected = Boolean(isSelected && connection && connection.getConnector() === activeConnector);\n    const isDisabled = Boolean(!isSelected && activeConnectorType && connection);\n    return { isSelected, isConnected, isDisabled, select };\n}\n", "import { Component } from 'react';\nimport { Network, WalletConnection, WalletConnectionDelegate, WalletConnector } from '@concordium/wallet-connectors';\nimport { errorString } from './error';\n\n/**\n * Activation/deactivation controller of a given connector type.\n */\nexport interface ConnectorType {\n    /**\n     * Called when the connection type is being activated.\n     * The connector instance returned by this method becomes the new {@link State.activeConnector activeConnector}.\n     * @param component The component in which the instance is being activated.\n     *                  This object doubles as the delegate to pass to new connector instances.\n     * @param network The network to pass to new connector instances.\n     */\n    activate(component: WithWalletConnector, network: Network): Promise<WalletConnector>;\n\n    /**\n     * Called from {@link WithWalletConnector} when the connection type is being deactivated,\n     * i.e. right after {@link State.activeConnector activeConnector} has been unset from this value.\n     * @param component The component in which the instance is being deactivated.\n     * @param connector The connector to deactivate.\n     */\n    deactivate(component: WithWalletConnector, connector: WalletConnector): Promise<void>;\n}\n\n/**\n * Produce a {@link ConnectorType} that creates a new connector instance on activation\n * and disconnects the existing one on deactivation.\n * This is the simplest connection type and should be used unless there's a reason not to.\n * @param create Factory function for creating new connector instances.\n */\nexport function ephemeralConnectorType(create: (c: WithWalletConnector, n: Network) => Promise<WalletConnector>) {\n    return {\n        activate: create,\n        deactivate: (w: WithWalletConnector, c: WalletConnector) => c.disconnect(),\n    };\n}\n\n/**\n * Produce a {@link ConnectorType} that reuse connectors between activation cycles.\n * That is, once a connector is created, it's never automatically disconnected.\n * Note that only the connector is permanent. Individual connections may still be disconnected by the application.\n * @param create Factory function for creating new connector instances.\n */\nexport function persistentConnectorType(create: (c: WithWalletConnector, n: Network) => Promise<WalletConnector>) {\n    const connectorPromises = new Map<WithWalletConnector, Map<Network, Promise<WalletConnector>>>();\n    return {\n        activate: (component: WithWalletConnector, network: Network) => {\n            const delegateConnectorPromises =\n                connectorPromises.get(component) || new Map<Network, Promise<WalletConnector>>();\n            connectorPromises.set(component, delegateConnectorPromises);\n            const connectorPromise = delegateConnectorPromises.get(network) || create(component, network);\n            delegateConnectorPromises.set(network, connectorPromise);\n            return connectorPromise;\n        },\n        deactivate: async () => undefined,\n    };\n}\n\n/**\n * The internal state of the component.\n */\ninterface State {\n    /**\n     * The active connector type. This value is updated using {@link WalletConnectionProps.setActiveConnectorType}.\n     * Changes to this value trigger activation of a connector managed by the connector type.\n     * This will cause {@link activeConnector} or {@link activeConnectorError} to change depending on the outcome.\n     */\n    activeConnectorType: ConnectorType | undefined;\n\n    /**\n     * The active connector. Connector instances get (de)activated appropriately when {@link activeConnectorType} changes.\n     *\n     * It's up to the {@link ConnectorType} in {@link activeConnectorType} to implement any synchronization between\n     * the active connector and {@link activeConnector}:\n     * In general, it is perfectly possible for the active connection to not originate from the active connector.\n     *\n     * If the application disconnects the active connector manually, they must also call\n     * {@link WalletConnectionProps.setActiveConnectorType} to\n     */\n    activeConnector: WalletConnector | undefined;\n\n    /**\n     * Any of the following kinds of errors:\n     * - Error activating a connector with {@link activeConnectorType}.\n     *   In this case {@link activeConnector} is undefined.\n     * - Error deactivating the previous connector.\n     *   In this case {@link activeConnectorType} and {@link activeConnector} are undefined.\n     */\n    activeConnectorError: string;\n\n    /**\n     * A map from open connections to their selected accounts or the empty string\n     * if the connection doesn't have an associated account.\n     */\n    connectedAccounts: Map<WalletConnection, string>;\n\n    /**\n     * A map from open connections to the hash of the genesis block for the chain that the selected accounts\n     * of the connections live on.\n     * Connections without a selected account (or the account's chain is unknown) will not have an entry in this map.\n     *\n     * TODO The reported hash values are not too reliable as they're updated only when the `onChainChanged` event fires.\n     *      And this doesn't happen when the connection is initiated.\n     *      For WalletConnect we could do that manually as we control what chain we connect to.\n     *      For BrowserWallet we don't have that option (see also https://concordium.atlassian.net/browse/CBW-633).\n     */\n    genesisHashes: Map<WalletConnection, string>;\n}\n\nfunction updateMapEntry<K, V>(map: Map<K, V>, key: K | undefined, value: V | undefined) {\n    const res = new Map(map);\n    if (key !== undefined) {\n        if (value !== undefined) {\n            res.set(key, value);\n        } else {\n            res.delete(key);\n        }\n    }\n    return res;\n}\n\ninterface Props {\n    /**\n     * The network on which the connected accounts are expected to live on.\n     *\n     * Changes to this value will cause all connections managed by {@link State.activeConnector} to get disconnected.\n     */\n    network: Network; // reacting to change in 'componentDidUpdate'\n\n    /**\n     * Function for generating the child component based on the props derived from the state of this component.\n     *\n     * JSX automatically supplies the nested expression as this prop field, so callers usually don't set it explicitly.\n     *\n     * @param props Connection state and management functions.\n     * @return Child component.\n     */\n    children: (props: WalletConnectionProps) => JSX.Element;\n}\n\n/**\n * The props to be passed to the child component.\n */\nexport interface WalletConnectionProps extends State {\n    /**\n     * The network provided to {@link WithWalletConnector} via its props.\n     *\n     * This is only passed for convenience as the value is always available to the child component anyway.\n     */\n    network: Network;\n\n    /**\n     * Function for setting or resetting {@link State.activeConnectorType activeConnectorType}.\n     *\n     * Any existing connector type value is deactivated and any new one is activated.\n     *\n     * @param type The new connector type or undefined to reset the value.\n     */\n    setActiveConnectorType: (type: ConnectorType | undefined) => void;\n}\n\n/**\n * React component that helps managing wallet connections\n * by introducing a notion of \"active\" {@link WalletConnector} and {@link WalletConnection},\n * and maintaining their states as part of its own component state.\n * This allows child components to access all relevant information in a reactive manner\n * and provides methods for managing the active connection.\n *\n * The component implements {@link WalletConnectionDelegate} and passes itself to all {@link WalletConnector}s\n * that it initializes.\n * This allows it to receive events from the underlying clients.\n * Once it receives an event for the active {@link WalletConnection},\n * it performs the relevant updates to its component state which then bubble down to child components.\n *\n * This component significantly reduces the complexity of integrating with wallets,\n * even if one only needs to support a single protocol and network.\n */\n// TODO Rename to WalletConnectionManager?\nexport class WithWalletConnector extends Component<Props, State> implements WalletConnectionDelegate {\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            activeConnectorType: undefined,\n            activeConnector: undefined,\n            activeConnectorError: '',\n            genesisHashes: new Map(),\n            connectedAccounts: new Map(),\n        };\n    }\n\n    /**\n     * @see WalletConnectionProps.setActiveConnectorType\n     */\n    setActiveConnectorType = (type: ConnectorType | undefined) => {\n        console.debug(\"WithWalletConnector: calling 'setActiveConnectorType'\", { type, state: this.state });\n        const { network } = this.props;\n        const { activeConnectorType, activeConnector } = this.state;\n        this.setState({\n            activeConnectorType: type,\n            activeConnector: undefined,\n            activeConnectorError: '',\n        });\n        if (activeConnectorType && activeConnector) {\n            activeConnectorType.deactivate(this, activeConnector).catch((err) =>\n                this.setState((state) => {\n                    // Don't set error if user switched connector type since initializing this connector.\n                    // It's OK to show it if the user switched away and back...\n                    if (state.activeConnectorType !== type) {\n                        return state;\n                    }\n                    return { ...state, activeConnectorError: errorString(err) };\n                })\n            );\n        }\n        if (type) {\n            type.activate(this, network)\n                .then((connector: WalletConnector) => {\n                    console.log('WithWalletConnector: setting active connector', { connector });\n                    // Switch the connector (type) back in case the user changed it since initiating the connection.\n                    this.setState({ activeConnectorType: type, activeConnector: connector, activeConnectorError: '' });\n                })\n                .catch((err) =>\n                    this.setState((state) => {\n                        if (state.activeConnectorType !== type) {\n                            return state;\n                        }\n                        return { ...state, activeConnectorError: errorString(err) };\n                    })\n                );\n        }\n    };\n\n    onAccountChanged = (connection: WalletConnection, address: string | undefined) => {\n        console.debug(\"WithWalletConnector: calling 'onAccountChanged'\", { connection, address, state: this.state });\n        this.setState((state) => ({\n            ...state,\n            connectedAccounts: updateMapEntry(state.connectedAccounts, connection, address || ''),\n        }));\n    };\n\n    onChainChanged = (connection: WalletConnection, genesisHash: string) => {\n        console.debug(\"WithWalletConnector: calling 'onChainChanged'\", { connection, genesisHash, state: this.state });\n        this.setState((state) => ({\n            ...state,\n            genesisHashes: updateMapEntry(state.genesisHashes, connection, genesisHash),\n        }));\n    };\n\n    onConnected = (connection: WalletConnection, address: string | undefined) => {\n        console.debug(\"WithWalletConnector: calling 'onConnected'\", { connection, state: this.state });\n        this.onAccountChanged(connection, address);\n    };\n\n    onDisconnected = (connection: WalletConnection) => {\n        console.debug(\"WithWalletConnector: calling 'onDisconnected'\", { connection, state: this.state });\n        this.setState((state) => ({\n            ...state,\n            connectedAccounts: updateMapEntry(state.connectedAccounts, connection, undefined),\n        }));\n    };\n\n    render() {\n        const { children, network } = this.props;\n        return children({ ...this.state, network, setActiveConnectorType: this.setActiveConnectorType });\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if (prevProps.network !== this.props.network) {\n            // Reset active connector and connection when user changes network.\n            // In the future there may be a mechanism for negotiating with the wallet.\n            this.setActiveConnectorType(undefined);\n        }\n    }\n\n    componentWillUnmount() {\n        // TODO Disconnect everything?\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "import_react", "import_react", "import_react", "__awaiter"]
}
